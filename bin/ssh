#!/usr/bin/env ruby

##
# Overrides the normal `ssh` command and ensure that
# * tmux is used automatically if available
# * bash prompt is customised if within EC2 and provides useful EC2 info

require 'base64'
require 'shellwords'

def get_scp_arguments
  scp_args = []

  all_args = ARGV.map { |arg| arg.split('=') }.flatten.compact
  {
    '-i' => '-i', # use custom identity
    '-P' => '-p'  # port mapping
  }.each do |ssh_arg, scp_arg|
    if all_args.include?(ssh_arg)
      val = all_args[all_args.index(ssh_arg) + 1]
      unless val.nil?
        scp_args += [ssh_arg, val]
      end
    end
  end

  scp_args
end

def ssh_args_info
  arguments = ARGV.dup
  run_command = false
  possible_commands = []
  last_arg = ''

  if arguments.length == 1
    host = arguments.first
  else
    arguments.each_with_index do |arg, index|
      if arg.match(/^\-\-$/)
        # -- indicates to SSH that a command follows
        if index == arguments.length - 1
          # there is none though
          arguments.delete_at(index)
          break
        else
          run_command = true
          break
        end
      elsif arg.match(%r{^sh|bash|/bin/bash|rsync})
        run_command = true
        break
      elsif arg.match(/^\-/)
        possible_commands = []
      else
        host = arg if possible_commands.length == 0
        possible_commands << arg unless last_arg.match(/^\-/)
      end

      last_arg = arg
    end
  end

  if possible_commands.length > 1
    run_command = true
  end

  {
    includes_command: run_command,
    host:             host
  }
end

ssh_info = ssh_args_info

# If more than one possible command exists such as `ssh host command_2`
# then we should not use tmux and instead run the command
if ARGV.length == 0 || ssh_info[:includes_command]
  # don't invoke tmux
  exec "/usr/bin/ssh #{ARGV.map { |arg| Shellwords.escape(arg) }.join(' ')}"
else
  tmux_config = File.read(File.expand_path('~/.dotfiles/scripts/tmux.config', __FILE__))
  tmux_status = File.read(File.expand_path('~/.dotfiles/scripts/tmux.status', __FILE__))
  custom_prompt = File.read(File.expand_path('~/.dotfiles/scripts/ssh.custom-prompt-and-tmux', __FILE__))
  htop_config = File.read(File.expand_path('~/.dotfiles/scripts/htop.config', __FILE__))

  exec %{/usr/bin/ssh #{ARGV.join(' ')} -t -- "if which /bin/sh > /dev/null; then
    if ! grep USE_EC2_COMMAND_PROMPT ~/.bashrc > /dev/null; then
      echo 'if [ -n \\$USE_EC2_COMMAND_PROMPT ]; then
        . ~/.custom-prompt-and-tmux > /dev/null || true
      fi' >> ~/.bashrc
    fi
    echo '#{Base64.encode64(custom_prompt)}' | base64 --decode > ~/.custom-prompt-and-tmux
    mkdir -p ~/.config/htop
    echo '#{Base64.encode64(htop_config)}' | base64 --decode > ~/.config/htop/htoprc
    echo '#{Base64.encode64(tmux_status)}' | base64 --decode > ~/.tmux_status
    chmod +x ~/.tmux_status
    rm /dev/shm/.tmux_status_host_info
    if which tmux > /dev/null; then
      echo '#{Base64.encode64(tmux_config)}' | base64 --decode > ~/.tmux.conf
      USE_EC2_COMMAND_PROMPT=true && /bin/sh -c 'tmux has-session && exec tmux attach || exec tmux'
    else
      USE_EC2_COMMAND_PROMPT=true && \\$SHELL
    fi
  else
    USE_EC2_COMMAND_PROMPT=true && \\$SHELL
  fi"}
end
